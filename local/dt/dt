#!/usr/bin/perl
# This script runs on the M1.

package DevMem;

use bytes;
use Sys::Mmap;
use File::Slurp qw(read_file);

my $mem;

sub new {
    my ($class, $dev, $off, $len) = @_;
    $dev //= "/dev/mem";
    if (!defined($off)) {
	($off, $len) = unpack("Q>Q>", scalar read_file("/sys/firmware/devicetree/base/memory\@800000000/reg"));
    }
    my $self = bless {}, $class;
    $self->{off} = $off;
    my $fh;
    open $fh, "+<$dev" or die;
    Sys::Mmap::mmap($mem, $len, PROT_READ|PROT_WRITE, MAP_SHARED, $fh, $off);
    return $self;
}

sub range {
    my ($self, $beg, $len) = @_;

    my $ret = substr($mem, $beg - $self->{off}, $len);

    return $ret;
}

sub fdtbeglen {
    my ($self, $path) = @_;
    my $fh;
    open $fh, $path or die;
    my ($beg, $len) = unpack("Q>Q>", scalar read_file($path));
    return ($beg, $len);
}

sub fdtrange {
    my ($self, $path) = @_;
    my $fh;
    open $fh, $path or die;
    my ($beg, $len) = unpack("Q>Q>", scalar read_file($path));
    return $self->range($beg, $len);
}

package MMIO;
use Time::HiRes;
use bytes;

sub read32 {
    my $addr = shift;
    if ($addr >= 0x682000000 && $addr < 0x684000000) {
	return 0;
    }
    # warn "memtool md $addr+4";
    my $val = `memtool md $addr+4`;
    chomp $val;
    my $ret;
    if ($val =~ /^[0-9a-f]*: ([0-9a-f]*) /) {
	$ret = hex $1;
    }
    # warn sprintf("memtool md 0x%lx+4 0x%lx", $addr, $ret);
    return $ret;
}

sub write32 {
    my ($addr, $value) = @_;

    if ($addr >= 0x682000000 && $addr < 0x684000000) {
	return;
    }
    # warn sprintf("memtool mw 0x%lx+4 0x%lx", $addr, $value);
    system("memtool mw $addr $value");
}

package DTNode;

use strict;
use bytes;

sub string {
    my ($self) = @_;
    my @ret;
    if (scalar($self->bytes) % 4) {
	return "[" . join(" ", map { sprintf("%02x", $_) } $self->bytes) . "]";
    }
    for my $le32 ($self->le32) {
	push @ret, $le32;
    }
    return "<" . join(" ", map { sprintf("0x%02x", $_) } @ret ) . ">";
}

sub le32 {
    my ($self) = @_;
    my @ret = unpack("L<*", pack("C*", @{$self->{bytes}}));
    return @ret;
}

sub bytes {
    my ($self) = @_;
    return @{$self->{bytes}};
}

sub addresses {
    my ($self) = @_;
    my @ret;
    if ($self->{le}) {
	@ret = unpack("Q<*", pack("C*", $self->bytes));
    } else {
	@ret = unpack("Q>*", pack("C*", $self->bytes));
    }
    return @ret;
}

sub ranges {
    my ($self) = @_;
    my @addresses = $self->addresses;
    my @ret;
    for (my $i = 0; $i < @addresses; $i += 2) {
	push @ret, [$addresses[$i], $addresses[$i+1]];
    }
    return @ret;
}

sub new {
    my ($class, $unit, @values) = @_;
    my $ret = bless {}, $class;

    if ($unit eq "str-le32") {
	if ($values[0] =~ /^<(.*)>$/) {
	    @values = map { hex($_) } split(" ", $1);
	    $unit = "le32";
	    $ret->{le} = 1;
	} elsif ($values[0] =~ /^\"(.*)\"$/) {
	    @values = map { ord($_) } split("", $1);
	    $unit = "u8";
	}
    }

    if ($unit eq "str-be32") {
	if ($values[0] =~ /^<(.*)>$/) {
	    @values = map { hex($_) } split(" ", $1);
	    $unit = "be32";
	    $ret->{le} = 0;
	} elsif ($values[0] =~ /^\"(.*)\"$/) {
	    @values = map { ord($_) } split("", $1);
	    $unit = "u8";
	}
    }

    if ($unit eq "str-le8") {
	if ($values[0] =~ /^\[(.*)\]$/) {
	    @values = map { hex($_) } split(" ", $1);
	    $unit = "u8";
	}
    }

    if ($unit eq "string") {
	if ($values[0] =~ /^\"(.*)\"$/) {
	    @values = map { ord($_) } split("", $1);
	    $unit = "u8";
	}
    }


    if ($unit eq "be32") {
	@values = unpack("C*", pack("L>*", @values));
	$unit = "u8";
    } elsif ($unit eq "le32") {
	@values = unpack("C*", pack("L<*", @values));
	$unit = "u8";
    } elsif ($unit eq "be64") {
	@values = unpack("C*", pack("Q>*", @values));
	$unit = "u8";
    } elsif ($unit eq "le64") {
	@values = unpack("C*", pack("Q<*", @values));
	$unit = "u8";
    }

    if ($unit eq "u8") {
	$ret->{bytes} = \@values;
    } else {
	die;
    }

    return $ret;
}

package TunableItem;

use bytes;

sub new {
    my $class = shift;
    my %h = @_;
    my $ret = bless \%h, $class;
    push @{$TunableItem::items{$ret->{adtnode}}}, $ret;
    return $ret;
}

sub encode {
    my ($self, $lreg) = @_;

    my @ret;
    return @ret unless $lreg;

    my @ranges = $lreg->ranges;
    my $offset;
    my $ri;
    for my $i (0 .. $#ranges) {
	my $range = $ranges[$i];
	if ($self->{addr} >= $range->[0] &&
	    $self->{addr} < $range->[0] + $range->[1]) {
	    $ri = $i;
	    $offset = $self->{addr} - $range->[0];
	}
    }

    die "couldn't find " . sprintf("%x", $self->{addr}) unless defined $ri;
    push @ret, ($offset + ($ri << 28), $self->{mask}, $self->{value});

    return @ret;
}

sub apply {
    my ($self, $off) = @_;
    $off //= 0;
    eval {
	if ($self->{size} == 4 || $self->{size} == 32) {
	    my $oldval = MMIO::read32($self->{addr} + $off);
	    $oldval &= ~$self->{mask};
	    $oldval |= $self->{value};
	    MMIO::write32($self->{addr} + $off, $oldval);
	} else {
	    # warn "unhandled size " . $self->{size};
	}
    };
    # sleep .5;
    return $self;
}

package Tunable;

use bytes;

sub new {
    my ($class, $kind, @args) = @_;

    my $new = "new_from_$kind";

    return $class->$new(@args);
}

sub new_from_fancy {
    my ($class, %h) = @_;
    my $abuf = $h{abuf};
    my $base = $h{base};
    my $ret = bless {}, $class;

    $ret->{items} = [];

    my @abuf = $abuf->le32;

    for (my $ai = 0; $ai < @abuf; $ai++) {
	eval {
	    my $offs = $abuf[$ai];
	    my $size = $offs >> 24;
	    $offs &= 0xffffff;
	    if ($size == 255) {
		$ai += 2;
		next;
	    }
	    if ($size == 0 || $size == 4 || $size == 32) {
		my $addr = $base + $offs;
		my $mask = $abuf[$ai + 1];
		my $value = $abuf[$ai + 2];
		my $size = 32;

		push @{$ret->{items}}, TunableItem->new(
		    addr => $addr,
		    mask => $mask,
		    value => $value,
		    size => $size,
		    adtnode => $h{adtnode},
		    );
		$ai += 2;
	    }
	};
    }

    return $ret;
}

sub new_from_legacy {
    my ($class, %h) = @_;
    my $abuf = $h{abuf};
    my $areg = $h{areg};
    my $ret = bless {}, $class;

    $ret->{items} = [];

    my @abuf = $abuf->le32;
    my @areg = $areg->ranges;

    for (my $ai = 0; $ai < @abuf; $ai += 4) {
	eval {
	    my $range_id = $abuf[$ai];
	    my $offs = $abuf[$ai + 1];
	    my $addr = $areg[$range_id][0] + $offs;
	    my $mask = $abuf[$ai + 2];
	    my $value = $abuf[$ai + 3];

	    push @{$ret->{items}}, TunableItem->new(
		addr => $addr,
		mask => $mask,
		value => $value,
		size => 32,
		adtnode => $h{adtnode},
		);
	};
    }

    return $ret;
}

sub new_from_plain {
    my ($class, %h) = @_;
    my $abuf = $h{abuf};
    my @bytes = $abuf->bytes;
    my $size = $h{size} // 1;
    my $xor = $h{xor} // ($size - 1);
    my @bytes2;
    for my $i (0 .. $#bytes) {
	$bytes2[$i] = $bytes[$i ^ $xor];
    }

    return \@bytes2;
}

sub new_from_fusemap {
    my ($class, %h) = @_;
    my $map = $h{map};
    my $ret = bless {}, $class;
    my $base = $h{base};
    for my $row (@$map) {
	my $value;
	my $mask;
	my ($src_addr, $dst_offs, $src_lsb, $src_width, $dst_lsb, $dst_width) = @$row;
	if ($h{doread}) {
	    $value = MMIO::read32($src_addr);
	} else {
	    die;
	}

	$value >>= $src_lsb;
	$value &= (1 << $src_width) - 1;
	$mask = (1 << $dst_width) - 1;
	$mask <<= $dst_lsb;
	$value <<= $dst_lsb;
	$value &= $mask;

	push @{$ret->{items}}, TunableItem->new(
	    addr => $base + $dst_offs,
	    mask => $mask,
	    value => $value,
	    adtnode => $h{adtnode},
	    );
    }

    return $ret;
}

sub new_from_pcie {
    my ($class, %h) = @_;
    my $abuf = $h{abuf};
    my $areg = $h{areg} || $h{aparentreg};
    return unless $areg;
    my $range = $h{range};
    my $base = $h{base};
    my $ret = bless {}, $class;
    my @abuf = $abuf->le32;
    for (my $ai = 0; $ai < @abuf; $ai += 6) {
	eval {
	    my $size = $abuf[$ai + 1];
	    my $offs = $abuf[$ai + 0];
	    my $addr = ($areg->ranges)[$range][0] + $offs + $base;
	    my $mask = $abuf[$ai + 2];
	    my $value = $abuf[$ai + 4];

	    push @{$ret->{items}}, TunableItem->new(
		addr => $addr,
		mask => $mask,
		value => $value,
		size => $size,
		adtnode => $h{adtnode},
		);
	};
    }

    return $ret;
}

sub encode_to_fancy {
    my ($self, $lreg) = @_;
    my @ret;

    for my $item (@{$self->{items}}) {
	push @ret, $item->encode($lreg);
    }

    return DTNode->new("le32", @ret)->string;
}

package main;

use strict;
use bytes;
use File::Slurp qw(read_file write_file);
use IPC::Run qw(run);

sub buf_to_bytes {
    my ($buf) = @_;
    my @res;
    for my $i (0 .. $#$buf) {
	$res[4*$i] = ($buf->[$i] & 255);
	$res[4*$i+1] = (($buf->[$i] >>  8) & 255);
	$res[4*$i+2] = (($buf->[$i] >> 16) & 255);
	$res[4*$i+3] = (($buf->[$i] >> 24) & 255);
    }

    return @res;
}

sub bytes_to_buf {
    my @bytes = @_;
    my @res;
    for my $i (0 .. $#bytes) {
	$res[$i/4] = 0 unless defined $res[$i/4];
	$res[$i/4] += $bytes[$i] << (8 * ($i % 4));
    }

    return @res;
}

my %ltunables;
my %tunables;
my %dt;
my %adt;

sub tunable {
    my ($adtnode, $dtnode, $kind, %props) = @_;
    my ($adtdev, $adtprop) = ($adtnode =~ /^(.*)\.(.*?)$/);
    my ($dtdev, $dtprop) = ($dtnode =~ /^(.*)\.(.*?)$/);
    my $dtreg = $dtdev . ".reg";
    my $adtreg = $adtdev . ".reg";
    my $adtparent = $adtdev;
    $adtparent =~ s/\.[^.]*$//;
    my $adtparentreg = $adtparent . ".reg";

    $props{adtnode} = $adtnode;

    for my $lnode (sort keys %dt) {
	my $rawnode = $lnode;
	$rawnode =~ s/\@[0-9a-f]*//;

	if ($dtreg eq $rawnode) {
	    $props{lreg} = $dt{$lnode};
	}
	my $rawdev = $rawnode;
	$rawdev =~ s/\.[^.]*$//;
	my $ldev = $lnode;
	$ldev =~ s/\.[^.]*$//;
	$props{lnode} = $ldev if $rawdev eq $dtdev;
    }
    for my $anode (sort keys %adt) {
	if ($adtreg eq $anode) {
	    $props{areg} = $adt{$anode};
	}
	if ($adtnode eq $anode) {
	    $props{abuf} = $adt{$anode};
	}
	if ($adtparent eq $anode) {
	    $props{aparent} = $adt{$anode};
	}
	if ($adtparentreg eq $anode) {
	    $props{aparentreg} = $adt{$anode};
	}
    }

    unless (exists $props{abuf} or exists $props{aparent}) {
	warn "no abuf for $adtnode";
	return;
    }
    my $new = "new_from_$kind";
    # warn "new tunable $new from $adtnode";
    $tunables{$adtnode} = Tunable->$new(%props, adtnode => $adtnode);
    if (ref $tunables{$adtnode} eq "Tunable") {
	eval {
	    $tunables{$adtnode} = $tunables{$adtnode}->encode_to_fancy($props{lreg});
	};
    } else {
	$tunables{$adtnode} = DTNode->new("u8", @{$tunables{$adtnode}})->string;
    }
    unless ($props{lnode}) {
	warn "no lnode for $adtnode";
	return;
    }

    $ltunables{$props{lnode} . "." . $dtprop} = $tunables{$adtnode} if $props{lnode};
}

sub setup_tunables {
    system("memtool mw 0x23d2b001c 0");
    my $pcie_fuse_map = [
	# /* src_addr, dst_offs, src_[lsb,width], dst_[lsb,width] */
	# XXX Why is this still here?
	[ 0x23d2bc084, 0x6238,  4, 6,  0, 7 ],
	[ 0x23d2bc084, 0x6220, 10, 3, 14, 3 ],
	[ 0x23d2bc084, 0x62a4, 13, 2, 17, 2 ],
	[ 0x23d2bc418, 0x522c, 27, 2,  9, 2 ],
	[ 0x23d2bc418, 0x522c, 13, 3, 12, 3 ],
	[ 0x23d2bc418, 0x5220, 18, 3, 14, 3 ],
	[ 0x23d2bc418, 0x52a4, 21, 2, 17, 2 ],
	[ 0x23d2bc418, 0x522c, 23, 5, 16, 5 ],
	[ 0x23d2bc418, 0x5278, 23, 3, 20, 3 ],
	[ 0x23d2bc418, 0x5018, 31, 1,  2, 1 ],
	[ 0x23d2bc41c, 0x1204,  0, 5,  2, 5 ],
	];

    my $acio_fuse_map = [
	# /* src_addr, dst_offs, src_[lsb,width], dst_[lsb,width] */
	[ 0x23d2bc438, 0x2a38, 19, 6,  0, 7 ],
	[ 0x23d2bc438, 0x2a38, 25, 6, 17, 7 ],
	[ 0x23d2bc438, 0x2aa4, 31, 1, 17, 2 ],
	[ 0x23d2bc438, 0x0a04, 14, 5,  2, 5 ],
	[ 0x23d2bc43c, 0x2aa4,  0, 1, 17, 2 ],
	[ 0x23d2bc43c, 0x2a20,  1, 3, 14, 3 ],
	[ 0x23d2bc438, 0x222c,  7, 2,  9, 2 ],
	[ 0x23d2bc438, 0x222c,  4, 3, 12, 3 ],
	[ 0x23d2bc438, 0x22a4, 12, 2, 17, 2 ],
	[ 0x23d2bc438, 0x2220,  9, 3, 14, 3 ],
	[ 0x23d2bc438, 0x0a04, 14, 5,  2, 5 ],
	];

    for my $v ([0, 0x380000000], [1, 0x500000000]) {
	my $i = $v->[0];
	my $base = $v->[1];

	eval {
	    MMIO::write32($base + 0x8bc, 1);
	    MMIO::write32($base + (1 << 15) + 0x8bc, 1);
	    # MMIO::write32($base + (2 << 15) + 0x8bc, 1);
	};
	tunable("arm-io.atc-phy${i}.tunable_ATC0AXI2AF",
		"soc.usb${i}.tunable-ATC0AXI2AF",
		fancy => base => $base);
	tunable("arm-io.usb-drd${i}.tunable",
		"soc.usb${i}.tunable",
		legacy =>);
	tunable("arm-io.atc-phy${i}.tunable_ATC0AXI2AF",
		"soc.atcphy${i}.tunable-ATC0AXI2AF",
		fancy => base => $base);
	tunable("arm-io.atc-phy${i}.tunable_ATC_FABRIC",
		"soc.atcphy${i}.tunable-ATC_FABRIC",
		fancy => base => $base + 0x3045000);
	tunable("arm-io.atc-phy${i}.tunable_AUS_CMN_SHM",
		"soc.atcphy${i}.tunable-AUS_CMN_SHM",
		fancy => base => $base + 0x3000a00);
	tunable("arm-io.atc-phy${i}.tunable_AUS_CMN_TOP",
		"soc.atcphy${i}.tunable-AUS_CMN_TOP",
		fancy => base => $base + 0x3000800);
	tunable("arm-io.atc-phy${i}.tunable_AUSPLL_CORE",
		"soc.atcphy${i}.tunable-AUSPLL_CORE",
		fancy => base => $base + 0x3002200);
	tunable("arm-io.atc-phy${i}.tunable_AUSPLL_TOP",
		"soc.atcphy${i}.tunable-AUSPLL_TOP",
		fancy => base => $base + 0x3002000);
	tunable("arm-io.atc-phy${i}.tunable_CIO3PLL_CORE",
		"soc.atcphy${i}.tunable-CIO3PLL_CORE",
		fancy => base => $base + 0x3002a00);
	tunable("arm-io.atc-phy${i}.tunable_CIO3PLL_TOP",
		"soc.atcphy${i}.tunable-CIO3PLL_TOP",
		fancy => base => $base + 0x3002800);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN0_AUSPMA_RX_EQ",
		"soc.atcphy${i}.tunable-CIO_LN0_AUSPMA_RX_EQ",
		fancy => base => $base + 0x300a000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN0_AUSPMA_RX_EQ",
		"soc.atcphy${i}.tunable-USB_LN0_AUSPMA_RX_EQ",
		fancy => base => $base + 0x300a000);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN0_AUSPMA_RX_SHM",
		"soc.atcphy${i}.tunable-CIO_LN0_AUSPMA_RX_SHM",
		fancy => base => $base + 0x300b000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN0_AUSPMA_RX_SHM",
		"soc.atcphy${i}.tunable-USB_LN0_AUSPMA_RX_SHM",
		fancy => base => $base + 0x300b000);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN0_AUSPMA_RX_TOP",
		"soc.atcphy${i}.tunable-CIO_LN0_AUSPMA_RX_TOP",
		fancy => base => $base + 0x3009000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN0_AUSPMA_RX_TOP",
		"soc.atcphy${i}.tunable-USB_LN0_AUSPMA_RX_TOP",
		fancy => base => $base + 0x3009000);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN0_AUSPMA_TX_TOP",
		"soc.atcphy${i}.tunable-CIO_LN0_AUSPMA_TX_TOP",
		fancy => base => $base + 0x300c000);
	tunable("arm-io.atc-phy${i}.tunable_DP_LN0_AUSPMA_TX_TOP",
		"soc.atcphy${i}.tunable-DP_LN0_AUSPMA_TX_TOP",
		fancy => base => $base + 0x300c000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN0_AUSPMA_TX_TOP",
		"soc.atcphy${i}.tunable-USB_LN0_AUSPMA_TX_TOP",
		fancy => base => $base + 0x300c000);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN1_AUSPMA_RX_EQ",
		"soc.atcphy${i}.tunable-CIO_LN1_AUSPMA_RX_EQ",
		fancy => base => $base + 0x3011000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN1_AUSPMA_RX_EQ",
		"soc.atcphy${i}.tunable-USB_LN1_AUSPMA_RX_EQ",
		fancy => base => $base + 0x3011000);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN1_AUSPMA_RX_SHM",
		"soc.atcphy${i}.tunable-CIO_LN1_AUSPMA_RX_SHM",
		fancy => base => $base + 0x3012000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN1_AUSPMA_RX_SHM",
		"soc.atcphy${i}.tunable-USB_LN1_AUSPMA_RX_SHM",
		fancy => base => $base + 0x3012000);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN1_AUSPMA_RX_TOP",
		"soc.atcphy${i}.tunable-CIO_LN1_AUSPMA_RX_TOP",
		fancy => base => $base + 0x3010000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN1_AUSPMA_RX_TOP",
		"soc.atcphy${i}.tunable-USB_LN1_AUSPMA_RX_TOP",
		fancy => base => $base + 0x3010000);
	tunable("arm-io.atc-phy${i}.tunable_CIO_LN1_AUSPMA_TX_TOP",
		"soc.atcphy${i}.tunable-CIO_LN1_AUSPMA_TX_TOP",
		fancy => base => $base + 0x3013000);
	tunable("arm-io.atc-phy${i}.tunable_DP_LN1_AUSPMA_TX_TOP",
		"soc.atcphy${i}.tunable-DP_LN1_AUSPMA_TX_TOP",
		fancy => base => $base + 0x3013000);
	tunable("arm-io.atc-phy${i}.tunable_USB_LN1_AUSPMA_TX_TOP",
		"soc.atcphy${i}.tunable-USB_LN1_AUSPMA_TX_TOP",
		fancy => base => $base + 0x3013000);
	tunable("arm-io.atc-phy${i}.tunable_USB_ACIOPHY_TOP",
		"soc.atcphy${i}.tunable-USB_ACIOPHY_TOP",
		fancy => base => $base + 0x3000000);
	# tunable("arm-io.acio${i}.fw_int_ctl_management_tunables",
	# 	"soc.acio${i}.tunable-fw_int_ctl_management",
	# 	pcie => range => 0, base => 0x04000);
	# tunable("arm-io.acio${i}.hbw_fabric_tunables",
	# 	"soc.acio${i}.tunable-hbw_fabric",
	# 	pcie => range => 3);
	# tunable("arm-io.acio${i}.hi_dn_merge_fabric_tunables",
	# 	"soc.acio${i}.tunable-hi_dn_merge_fabric",
	# 	pcie => range => 0, base => 0xfc000);
	# tunable("arm-io.acio${i}.hi_up_merge_fabric_tunables",
	# 	"soc.acio${i}.tunable-hi_up_merge_fabric",
	# 	pcie => range => 0, base => 0xf8000);
	# tunable("arm-io.acio${i}.hi_up_tx_desc_fabric_tunables",
	# 	"soc.acio${i}.tunable-hi_up_tx_desc_fabric",
	# 	pcie => range => 0, base => 0xf0000);
	# tunable("arm-io.acio${i}.hi_up_tx_data_fabric_tunables",
	# 	"soc.acio${i}.tunable-hi_up_tx_data_fabric",
	# 	pcie => range => 0, base => 0xec000);
	# tunable("arm-io.acio${i}.hi_up_rx_desc_fabric_tunables",
	# 	"soc.acio${i}.tunable-hi_up_rx_desc_fabric",
	# 	pcie => range => 0, base => 0xe8000);
	# tunable("arm-io.acio${i}.hi_up_wr_fabric_tunables",
	# 	"soc.acio${i}.tunable-hi_up_wr_fabric",
	# 	pcie => range => 0, base => 0xf4000);
	# tunable("arm-io.acio${i}.lbw_fabric_tunables",
	# 	"soc.acio${i}.tunable-lbw_fabric",
	# 	pcie => range => 4);
	# tunable("arm-io.acio${i}.pcie_adapter_regs_tunables",
	# 	"soc.acio${i}.tunable-pcie_adapter_regs",
	# 	pcie => range => 5);
	# tunable("arm-io.acio${i}.top_tunables",
	# 	"soc.acio${i}.tunable-top",
	# 	pcie => range => 2);
	# tunable("arm-io.acio${i}.thunderbolt-drom",
	# 	"soc.acio${i}.thunderbolt-drom",
	# 	plain => size => 4);
	tunable("arm-io.apciec${i}.atc-apcie-debug-tunables",
		"soc.pciec${i}.tunable-debug",
		pcie => range => 6);
	tunable("arm-io.apciec${i}.atc-apcie-fabric-tunables",
		"soc.pciec${i}.tunable-fabric",
		pcie => range => 4);
	tunable("arm-io.apciec${i}.atc-apcie-oe-fabric-tunables",
		"soc.pciec${i}.tunable-oe-fabric",
		pcie => range => 5);
	tunable("arm-io.apciec${i}.atc-apcie-rc-tunables",
		"soc.pciec${i}.tunable-rc",
		pcie => range => 0);
	tunable("arm-io.apciec${i}.pcic${i}-bridge.apcie-config-tunables",
		"soc.pciec${i}.tunable-port0-config",
		pcie => range => 3, parent => 1);
	if (0) {
	    eval {
		tunable("arm-io.apcie.apcie-axi2af-tunables",
			"soc.pcie.tunable-axi2af",
			pcie => range => 4);
	    };
	}
	tunable("arm-io.apcie.apcie-common-tunables",
		"soc.pcie.tunable-common",
		pcie => range => 1);
	tunable("arm-io.apcie.apcie-phy-ip-auspma-tunables",
		"soc.pcie.tunable-phy-ip-auspma",
		pcie => range => 3);
	tunable("arm-io.apcie.apcie-phy-ip-pll-tunables",
		"soc.pcie.tunable-phy-ip-pll",
		pcie => range => 3);
	tunable("arm-io.apcie.apcie-phy-tunables",
		"soc.pcie.tunable-phy",
		pcie => range => 2);
	tunable("arm-io.apcie.pci-bridge0.apcie-config-tunables",
		"soc.pcie.tunable-port0-config",
		pcie => parent => 1, range => 6);
	tunable("arm-io.apcie.pci-bridge0.pcie-rc-gen3-shadow-tunables",
		"soc.pcie.tunable-port0-gen3-shadow",
		pcie => parent => 1, range => 0);
	tunable("arm-io.apcie.pci-bridge0.pcie-rc-gen4-shadow-tunables",
		"soc.pcie.tunable-port0-gen4-shadow",
		pcie => parent => 1, range => 0);
	tunable("arm-io.apcie.pci-bridge0.pcie-rc-tunables",
		"soc.pcie.tunable-port0",
		pcie => parent => 1, range => 0);
	if (0) {
	tunable("arm-io.apcie.pci-bridge1.apcie-config-tunables",
		"soc.pcie.tunable-port1-config",
		pcie => parent => 1, range => 10);
	tunable("arm-io.apcie.pci-bridge1.pcie-rc-gen3-shadow-tunables",
		"soc.pcie.tunable-port1-gen3-shadow",
		pcie => parent => 1, range => 0, base => 0x8000);
	tunable("arm-io.apcie.pci-bridge1.pcie-rc-gen4-shadow-tunables",
		"soc.pcie.tunable-port1-gen4-shadow",
		pcie => parent => 1, range => 0, base => 0x8000);
	tunable("arm-io.apcie.pci-bridge1.pcie-rc-tunables",
		"soc.pcie.tunable-port1",
		pcie => parent => 1, range => 0, base => 0x8000);
	tunable("arm-io.apcie.pci-bridge2.apcie-config-tunables",
		"soc.pcie.tunable-port2-config",
		pcie => parent => 1, range => 14);
	tunable("arm-io.apcie.pci-bridge2.pcie-rc-gen3-shadow-tunables",
		"soc.pcie.tunable-port2-gen3-shadow",
		pcie => parent => 1, range => 0, base => 0x10000);
	tunable("arm-io.apcie.pci-bridge2.pcie-rc-gen4-shadow-tunables",
		"soc.pcie.tunable-port2-gen4-shadow",
		pcie => parent => 1, range => 0, base => 0x10000);
	tunable("arm-io.apcie.pci-bridge2.pcie-rc-tunables",
		"soc.pcie.tunable-port2",
		pcie => parent => 1, range => 0, base => 0x10000);
	#tunable("chosen.mac-address-ethernet0",
	#	"chosen.hwaddr-eth0",
	#	plain =>);
	}
	tunable("arm-io.pmgr.voltage-states1",
		"soc.cpufreq.tunable-ecpu-states",
		plain => xor => 0);
	tunable("arm-io.pmgr.voltage-states5",
		"soc.cpufreq.tunable-pcpu-states",
		plain => xor => 0);
	tunable("arm-io.pmgr.mcx-fast-pcpu-frequency",
		"soc.cpufreq.tunable-pcpu-fast-freq",
		plain => xor => 0);
	tunable("arm-io.mcc.dramcfg-data",
		"soc.cpufreq.tunable-pcpu-fast-dcfg",
		plain => xor => 0);
	#tunable("chosen.mac-address-wifi0",
	#	"chosen.hwaddr-wlan0",
	#	plain =>);
	#tunable("chosen.mac-address-bluetooth0",
	#	"chosen.hwaddr-bt0",
	#	plain =>);
	#tunable("arm-io.wlan.module-instance",
	#	"chosen.module-wlan0",
	#	plain =>);

	tunable("arm-io.atc-phy${i}.reg",
		"soc.atcphy${i}.tunable-fuse",
		fusemap => map => $acio_fuse_map, base => $base + 0x3000000, doread => 1);

	tunable("arm-io.apcie.reg",
		"soc.pcie.tunable-fuse",
		fusemap => map => $pcie_fuse_map, base => 0x6800c0000, doread => 1);
    }
}

sub apply_tunable {
    my ($str, $off) = @_;
    $off //= 0;
    my @tunables;
    for my $key (sort keys %TunableItem::items) {
	if (substr($key, length($key) - length($str)) eq $str) {
	    push @tunables, @{${TunableItem::items{$key}}};
	}
    }

    unless(@tunables) {
	# warn "couldn't find $str\n";
	for my $key (sort keys %TunableItem::items) {
	    # warn "nomatch: $key";
	}
	return;
    }

    for my $tunable (@tunables) {
	$tunable->apply($off);
    }
}

sub BIT {
    return 1 << ($_[0]);
}

my $APCIE_PHY_CTRL         = 0x000;
my $APCIE_PHY_CTRL_CLK0REQ = BIT(0);
my $APCIE_PHY_CTRL_CLK1REQ = BIT(1);
my $APCIE_PHY_CTRL_CLK0ACK = BIT(2);
my $APCIE_PHY_CTRL_CLK1ACK = BIT(3);
my $APCIE_PHY_CTRL_RESET   = BIT(7);

my $DWC_DBI_RO_WR    = 0x8bc;
my $DWC_DBI_RO_WR_EN = BIT(0);

sub enable_phy_clks {
    my ($phy_base) = @_;
    MMIO::write32($phy_base + $APCIE_PHY_CTRL,
		  MMIO::read32($phy_base + $APCIE_PHY_CTRL) | $APCIE_PHY_CTRL_CLK0REQ);
    while (!(MMIO::read32($phy_base + $APCIE_PHY_CTRL) & $APCIE_PHY_CTRL_CLK0ACK)) {
	# warn MMIO::read32($phy_base + $APCIE_PHY_CTRL) . " not set";
    }

    # warn "enabled PHY clk 0";

    MMIO::write32($phy_base + $APCIE_PHY_CTRL,
		  MMIO::read32($phy_base + $APCIE_PHY_CTRL) | $APCIE_PHY_CTRL_CLK1REQ);
    while (!(MMIO::read32($phy_base + $APCIE_PHY_CTRL) & $APCIE_PHY_CTRL_CLK1ACK)) {
	# warn MMIO::read32($phy_base + $APCIE_PHY_CTRL) . " not set";
    }

    # warn "enabled PHY clk 1";
}

sub mystery_rc {
    my ($rc_base) = @_;
    MMIO::write32($rc_base + 0x24, MMIO::read32($rc_base + 0x24) | 1);
}

sub make_regs_writable {
    my ($config_base) = @_;
    MMIO::write32($config_base + $DWC_DBI_RO_WR,
		  MMIO::read32($config_base + $DWC_DBI_RO_WR) | 1);
}

sub make_regs_readonly {
    my ($config_base) = @_;
    MMIO::write32($config_base + $DWC_DBI_RO_WR,
		  MMIO::read32($config_base + $DWC_DBI_RO_WR) & ~1);
}

my $APCIE_PORT_APPCLK    = 0x800;
my $APCIE_PORT_APPCLK_EN = BIT(0);
my $APCIE_PORT_STATUS    =  0x804;
my $APCIE_PORT_STATUS_RUN=  BIT(0);
my $APCIE_PORT_RESET     = 0x814;
my $APCIE_PORT_RESET_DIS = BIT(0);

sub enable_appclk {
    my ($port_base) = @_;
    my $count = 0;
    MMIO::write32($port_base + $APCIE_PORT_APPCLK,
		  MMIO::read32($port_base + $APCIE_PORT_APPCLK) | $APCIE_PORT_APPCLK_EN);
    MMIO::write32($port_base + $APCIE_PORT_RESET,
		  MMIO::read32($port_base + $APCIE_PORT_RESET) | $APCIE_PORT_RESET_DIS);
    until (MMIO::read32($port_base + $APCIE_PORT_STATUS) & $APCIE_PORT_STATUS_RUN) {
	# warn "not yet ready\n";
	if ($count++ > 1000) {
	    last;
	}
    }
    # warn "ready!";
}

my $DWC3_DCTL = 0xc704;
my $DWC3_GCTL = 0xc110;

my $DWC3_DCTL_CSFTRST = (1 << 30);
my $DWC3_GCTL_CORESOFTRESET = (1 << 11);

my $DWC3_GUSB2PHYCFG = 0xc200;
my $DWC3_GUSB3PIPECTL = 0xc2c0;

my $DWC3_GUSB2PHYCFG_PHYSOFTRST = (1 << 31);
my $DWC3_GUSB3PIPECTL_PHYSOFTRST = (1 << 31);

my $DWC3_GCTL_SCALEDOWN_MASK = 0x30;
my $DWC3_GCTL_DISSCRAMBLE = 8;

sub bring_up_phy {
    my ($base) = @_;

    MMIO::write32($base + 0x810008, 0x1c1000f);
    MMIO::write32($base + 0x810004, 3);
    MMIO::write32($base + 0x810004, 0);
    MMIO::write32($base + 0x81001c, 0x8c0813);
    MMIO::write32($base + 0x810000, 2);

    MMIO::write32($base + 0x80400c, 2);
    MMIO::write32($base + 0x80400c, 0x22);
    MMIO::write32($base + 0x80401c, 0x21);
    MMIO::write32($base + 0x804020, 0x9332);

    MMIO::write32($base + $DWC3_DCTL,
		  MMIO::read32($base + $DWC3_DCTL) | $DWC3_DCTL_CSFTRST);
    MMIO::write32($base + $DWC3_GCTL,
		  MMIO::read32($base + $DWC3_GCTL) | $DWC3_GCTL_CORESOFTRESET);

    MMIO::write32($base + $DWC3_GUSB3PIPECTL,
		  MMIO::read32($base + $DWC3_GUSB3PIPECTL) | $DWC3_GUSB3PIPECTL_PHYSOFTRST);
    MMIO::write32($base + $DWC3_GUSB2PHYCFG,
		  MMIO::read32($base + $DWC3_GUSB2PHYCFG) | $DWC3_GUSB2PHYCFG_PHYSOFTRST);

    MMIO::write32($base + $DWC3_GUSB3PIPECTL,
		  MMIO::read32($base + $DWC3_GUSB3PIPECTL) & ~$DWC3_GUSB3PIPECTL_PHYSOFTRST);
    MMIO::write32($base + $DWC3_GUSB2PHYCFG,
		  MMIO::read32($base + $DWC3_GUSB2PHYCFG) & ~$DWC3_GUSB2PHYCFG_PHYSOFTRST);

    MMIO::write32($base + $DWC3_GCTL,
		  MMIO::read32($base + $DWC3_GCTL) & ~$DWC3_GCTL_CORESOFTRESET);
    MMIO::write32($base + $DWC3_GCTL,
		  MMIO::read32($base + $DWC3_GCTL) & ~($DWC3_GCTL_SCALEDOWN_MASK | $DWC3_GCTL_DISSCRAMBLE));
}

sub bring_up_phys {
    bring_up_phy(0x382280000);
}

sub apply_tunables {
    bring_up_phys();
    apply_tunable("apcie-axi2af-tunables");
    apply_tunable("apcie-common-tunables");
    apply_tunable("apcie-phy-tunables");

    enable_phy_clks(0x680080000);
    mystery_rc(0x680000000);

    apply_tunable("apcie.reg");
    apply_tunable("apcie-phy-ip-pll-tunables");
    apply_tunable("apcie-phy-ip-auspma-tunables");
    apply_tunable("apcie-config-tunables");

    enable_appclk(0x681000000);
    enable_appclk(0x682000000);
    enable_appclk(0x683000000);

    make_regs_writable(0x690000000);

    apply_tunable("pcie-rc-tunables");
    apply_tunable("pcie-rc-gen3-shadow-tunables");
    apply_tunable("pcie-rc-gen4-shadow-tunables");

    make_regs_readonly(0x690000000);

    apply_tunable("apcie-config-tunables", 0x8000);
    make_regs_writable(0x690008000);

    apply_tunable("pcie-rc-tunables", 0x8000);
    apply_tunable("pcie-rc-gen3-shadow-tunables", 0x8000);
    apply_tunable("pcie-rc-gen4-shadow-tunables", 0x8000);

    make_regs_readonly(0x690008000);

    apply_tunable("apcie-config-tunables", 0x10000);
    make_regs_writable(0x690010000);

    apply_tunable("pcie-rc-tunables", 0x10000);
    apply_tunable("pcie-rc-gen3-shadow-tunables", 0x10000);
    apply_tunable("pcie-rc-gen4-shadow-tunables", 0x10000);

    make_regs_readonly(0x690010000);

    # warn "initialized";
}

sub tunables {
    my ($adtp, $ldtp) = @_;
    my $out = "";

    for (split "\n", $adtp) {
	my ($prop, $pval);
	my @pbuf;
	chomp;
	if (/^(.*?) = (.*)$/) {
	    ($prop, $pval) = ($1, $2);
	    $prop =~ s/^adt\.device-tree\.//;
	    $adt{$prop} = DTNode->new("str-le32", $pval) if $pval =~ /^<(.*)>$/;
	    $adt{$prop} = DTNode->new("str-le8", $pval) if $pval =~ /^\[(.*)\]$/;
	    $adt{$prop} = DTNode->new("string", $pval) if $pval =~ /^\"(.*)\"$/;
	    die $pval unless $adt{$prop};
	}
    }

    for (split "\n", $ldtp) {
	my ($prop, $pval);
	my @pbuf;
	chomp;
	if (/^(.*?) = (.*)$/) {
	    ($prop, $pval) = ($1, $2);
	    $dt{$prop} = DTNode->new("str-be32", $pval) if $pval =~ /^<(.*)>$/;
	    $dt{$prop} = DTNode->new("str-le8", $pval) if $pval =~ /^\[(.*)\]$/;
	}
    }

    my $ret = "";
    eval {
	setup_tunables();

	for my $key (sort keys %ltunables) {
	    eval {
		$ret .= ("$key = " . $ltunables{$key} . "\n");
	    };
	}
    };

    return $ret;
}

sub usage {
    my $program = "dt";
    warn "${program} adt-to-dtp <adt file> <dtp file>: convert ADT binary format to DT property format\n";
    warn "${program} dtb-to-dtp <adt file> <dtp file>: convert DTB binary format to DT property format\n";
    warn "${program} dtp-to-dtb <adt file> <dtp file>: convert DT property format to DTB binary format\n";
    warn "${program} tunables <adt file> <dtb file> <output dtp file>: extract tunables from ADT binary format\n";
    warn "${program} extract-adt <adt file>: extract ADT from currently executing firmware\n";
    warn "${program} dts-to-dtp <adt file> <dtp file>: convert DT source format to DT property format\n";
    warn "${program} dtp-to-dts <adt file> <dtp file>: convert DT property format to DT source format\n";
}

sub dts_to_dtp {
    my $dts = shift;
    my $dtp = "";
    my @lines = split("\n", $dts);
    my @path = ();
    for (@lines) {
	next if /^\//;
	s/^[\t ]*//;
	if (/^};/) {
	    pop @path;
	} elsif (/^(.*) {/) {
	    push @path, "$1.";
	} elsif (/^(.*?) = (.*);$/) {
	    $dtp .= (join("", @path) . "$1 = $2\n");
	} elsif (/^(.*?);$/) {
	    $dtp .= (join("", @path) . "$1\n");
	} elsif (/^[ \t]*$/) {
	} else {
	    die "bad line $_";
	}
    }
    die unless @path == 0;
    return $dtp;
}

sub dtp_to_dts {
    my %fdt;
    my @fdt;
    for (split("\n", shift)) {
	if (/^(.*?)([^. ]*) = (.*)$/) {
	    push @fdt, $1 unless exists $fdt{$1};
	    @{$fdt{$1}} = grep { $_->[0] ne $2 } @{$fdt{$1}};
	    push @{$fdt{$1}}, [$2, $3];
	} elsif (/^(.*?)([^. ]*)$/) {
	    push @fdt, $1 unless exists $fdt{$1};
	    @{$fdt{$1}} = grep { $_->[0] ne $2 } @{$fdt{$1}};
	    push @{$fdt{$1}}, [$2];
	}
    }

    my $dts = "";
    $dts .= "/dts-v1/;\n";
    $dts .= "/ {\n";
    my @lastpath;
    my $node = "";
    for my $propval (@{$fdt{$node}}) {
	my ($prop, $val) = @$propval;
	if (defined $val) {
	    $dts .= (("    " x (@lastpath + 1)) . "$prop = $val;\n");
	} else {
	    $dts .= (("    " x (@lastpath + 1)) . "$prop;\n");
	}
    }
    while (@fdt) {
	my $node = shift @fdt;
	my @path = split /\./, $node;
	if ($path[0] eq "") { @path = (); }
	while (@lastpath && $lastpath[$#lastpath] ne $path[$#lastpath]) {
	    pop @lastpath;
	    $dts .= (("    " x (@lastpath + 1)) . "};\n");
	}
	while (@path > @lastpath) {
	    $dts .= (("    " x (@lastpath + 1)) . "$path[@lastpath] {\n");
	    push @lastpath, $path[@lastpath];
	    if (@path == @lastpath) {
		for my $propval (@{$fdt{$node}}) {
		    my ($prop, $val) = @$propval;
		    if (defined $val) {
			$dts .= (("    " x (@lastpath + 1)) . "$prop = $val;\n");
		    } else {
			$dts .= (("    " x (@lastpath + 1)) . "$prop;\n");
		    }
		}
	    }
	}
	my @cnodes;
	my @ncnodes;
	for my $node2 (@fdt) {
	    if (substr($node2, 0, length($node)) eq $node) {
		push @cnodes, $node2;
	    } else {
		push @ncnodes, $node2;
	    }
	}
	@fdt = (@cnodes, @ncnodes);
    }
    while (@lastpath) {
	pop @lastpath;
	$dts .= (("    " x (@lastpath + 1)) . "};\n");
    }

    $dts .= ("};\n");

    return $dts;
}

sub dts_to_dtb {
    my $dts = shift;
    my $dtb = "";
    run(["dtc", "-q", "-Idts", "-Odtb"], \$dts, \$dtb) or die;

    return $dtb;
}

sub dtb_to_dts {
    my $dts = "";
    my $dtb = shift;
    run(["dtc", "-q", "-Idtb", "-Odts"], \$dtb, \$dts) or die;

    return $dts;
}

sub dtb_to_dtp {
    return dts_to_dtp(dtb_to_dts($_[0]));
}

sub adt_to_dtp {
    my $adt = shift;
    my $dtp = "";
    my $stdin = "";
    run(["adtp", "/dev/stdin"], \$adt, \$dtp) or die;
    return $dtp;
}

sub propertize_bootargs {
    my $bootargs = shift;
    my ($revver, $resvd0, $virt_base, $phys_base, $mem_size,
	$top_of_kernel, $fb_phys, $fb_display, $fb_stride,
	$fb_width, $fb_height, $fb_depth, $machine_type, $resvd1,
	$dtree_virt, $dtree_size, $cmdline) =
	unpack "LLQQQQQQQQQQLLQLZ", $bootargs;

    my $ret = "";
    my $fb_reg0 = sprintf("0x%02x", ($fb_phys>>32));
    my $fb_reg1 = sprintf("0x%02x", ($fb_phys & 0xffffffff));
    my $fb_len = $fb_stride * $fb_height;
    my $fb_reg2 = sprintf("0x%02x", ($fb_len>>32));
    my $fb_reg3 = sprintf("0x%02x", ($fb_len & 0xffffffff));
    $ret .= "framebuffer\@9e0df8000.reg = <$fb_reg0 $fb_reg1 $fb_reg2 $fb_reg3>\n";
    $fb_height = sprintf("0x%02x", $fb_height);
    $fb_width = sprintf("0x%02x", $fb_width);
    $fb_stride = sprintf("0x%02x", $fb_stride);
    $ret .= "framebuffer\@9e0df8000.height = <$fb_height>\n";
    $ret .= "framebuffer\@9e0df8000.width = <$fb_width>\n";
    $ret .= "framebuffer\@9e0df8000.stride = <$fb_stride>\n";

    return $ret;
}

my $stdin = "";
if ($ARGV[0] eq "--help") {
    usage();
    exit(1);
} elsif ($ARGV[0] eq "adt-to-dtp") {
    my $adt = read_file($ARGV[1]);
    my $dtp = adt_to_dtp($adt);
    write_file($ARGV[2], $dtp) or die;
} elsif ($ARGV[0] eq "dtb-to-dtp") {
    my $dts = "";
    run(["dtc", "-q", "-Idtb", "-Odts", $ARGV[1]], \$stdin, \$dts) or die;
    my $dtp = dts_to_dtp($dts);
    write_file($ARGV[2], $dtp) or die;
} elsif ($ARGV[0] eq "dts-to-dtp") {
    my $dts = read_file($ARGV[1]);
    my $dtp = dts_to_dtp($dts);
    write_file($ARGV[2], $dtp) or die;
} elsif ($ARGV[0] eq "dtp-to-dts") {
    my $dtp = read_file($ARGV[1]);
    my $dts = dtp_to_dts($dtp);
    write_file($ARGV[2], $dts) or die;
} elsif ($ARGV[0] eq "dtp-to-dtb") {
    my @argv = @ARGV;
    my $dtp = read_file($argv[1]);
    my $dts = dtp_to_dts($dtp);
    my $dtb = dts_to_dtb($dts);
    write_file($argv[2], $dtb) or die;
} elsif ($ARGV[0] eq "tunables") {
    my $adt = read_file($ARGV[1]);
    my $ldt = read_file($ARGV[2]);
    my $adtp = adt_to_dtp($adt);
    my $ldtp = dtb_to_dtp($ldt);
    my $odtp = tunables($adtp, $ldtp);
    write_file($ARGV[3], $odtp) or die;
    apply_tunables();
} elsif ($ARGV[0] eq "extract-adt") {
    my $adt = "";
    run(["adtdump"], \$stdin, \$adt) or die;
    write_file($ARGV[1], $adt) or die;
} elsif ($ARGV[0] eq "adt-model") {
    my $adt = read_file($ARGV[1]);
    my $adtp = adt_to_dtp($adt);
    for my $line (split "\n", $adtp) {
	if ($line =~ /^adt\.device-tree\.compatible = \[(.*?)\]$/) {
	    my @bytes = split / /, $1;
	    @bytes = map { chr hex $_ } @bytes;
	    my $strs = join("", @bytes);
	    my @strs = split("\0", $strs);
	    for my $str (@strs) {
		print "$str\n";
	    }
	} elsif ($line =~ /^adt\.device-tree\.target-type = \[(.*?)\]$/) {
	    my @bytes = split / /, $1;
	    @bytes = map { chr hex $_ } @bytes;
	    my $strs = join("", @bytes);
	    my @strs = split("\0", $strs);
	    for my $str (@strs) {
		print "$str\n";
	    }
	}
    }
} elsif ($ARGV[0] eq "adt-pearl") {
    my $adt = read_file($ARGV[1]);
    my $adtp = adt_to_dtp($adt);
    for my $line (split "\n", $adtp) {
	if ($line =~ /^adt\.device-tree\.chosen\.nvram-proxy-data = <(.*?)>$/) {
	    my @words = map { hex } split " ", $1;
	    my $data = pack("L<*", @words);
	    my @vars = split("\0", $data);
	    for my $var (@vars) {
		print "$2\n" if $var =~ /^(pearl)=(.*)$/;
	    }
	}
    }
} elsif ($ARGV[0] eq "extract-payload") {
    my $devmem = DevMem->new;
    my $bootargs;
    run(["adtdump", "--bootargs"], \$stdin, \$bootargs) or die;
    my $macho_header;
    run(["adtdump", "--macho-header"], \$stdin, \$macho_header) or die;
    my $off = 0;
    while (substr($macho_header, $off, 9) ne "__PAYLOAD") {
	die if $off++ > 16384;
    }
    $off += 0x18;
    my $len = unpack("Q<", substr($macho_header, $off, 8));
    $off += 8;
    my $file_off = unpack("Q<", substr($macho_header, $off, 8));
    my $base = unpack("Q>", substr(read_file("/sys/firmware/devicetree/base/reserved-memory/base\@800000000/reg"), 0, 8));
    my $end = unpack("Q<", substr($bootargs, 0x20, 8));
    my $start = $end - $len;
    my $range = $devmem->range($base + $file_off, $len);
    my $taillen = 1;
    $taillen *= 2 while ($taillen < $len);
    while ($taillen) {
	if (substr($range, length($range) - $taillen) eq "\0" x $taillen) {
	    $range = substr($range, 0, length($range) - $taillen);
	}
	$taillen = int($taillen / 2);
    }
    write_file($ARGV[1], $range);
} elsif ($ARGV[0] eq "extract-bootargs") {
    my $bootargs;
    run(["adtdump", "--bootargs"], \$stdin, \$bootargs) or die;
    write_file($ARGV[1], propertize_bootargs($bootargs)) or die;
} elsif ($ARGV[0] eq "permallocs") {
    my $fh;
    open $fh, "/sys/kernel/debug/permallocs/permallocs";
    my %reserved;
    while (<$fh>) {
	chomp;
	if (/^reserved: <([0-9a-f]*) ([0-9a-f]*) ([0-9a-f]*) ([0-9a-f]*)>;?$/) {
	    my ($addr_lo, $addr_hi, $len_lo, $len_hi) =
		(hex $1, hex $2, hex $3, hex $4);
	    my $addr = ($addr_hi << 32) + $addr_lo;
	    my $len = ($len_hi << 32) + $len_lo;
	    $reserved{$addr} = $addr + $len;
	} elsif (/^spin-table: <([0-9a-f]*) ([0-9a-f]*) ([0-9a-f]*) ([0-9a-f]*)>;?$/) {
	    print "spin-table.compatible = \"spin-table\"\n";
	    print "spin-table.reg = <0x$2 0x$1 0x$4 0x$3>\n";
	} elsif (/^spin-table: (.*?);?$/) {
	    print "spin-table.compatible = \"spin-table\"\n";
	    print "spin-table.reg = $1\n";
	} elsif (/^([0-9a-f]*)\.(.*?): (.*?);?$/) {
	    print "soc.$2\@$1.$3\n";
	}
    }

    my $didsomething = 1;
    while ($didsomething) {
	$didsomething = 0;
	for my $addr (keys %reserved) {
	    my $eaddr = $reserved{$addr};
	    if ($reserved{$eaddr}) {
		$reserved{$addr} = $reserved{$eaddr};
		delete $reserved{$eaddr};
		$didsomething = 1;
	    }
	}
    }
    for my $addr (sort { $a <=> $b } keys %reserved) {
	my $haddr = sprintf("%016x", $addr);
	my $haddr_hi = substr($haddr, 0, 8);
	my $haddr_lo = substr($haddr, 8);
	my $shaddr = sprintf("%x", $addr);
	my $hlen = sprintf("%016x", $reserved{$addr} - $addr);
	my $hlen_hi = substr($hlen, 0, 8);
	my $hlen_lo = substr($hlen, 8);
	print "reserved-memory.fw_area\@$shaddr.reg = <0x$haddr_hi 0x$haddr_lo 0x$hlen_hi 0x$hlen_lo>\n";
    }
} elsif ($ARGV[0] eq "mem-min") {
    my $fh;
    open $fh, "/sys/kernel/debug/permallocs/permallocs";
    my $mem_min = 0x800000000;
    while (<$fh>) {
	chomp;
	if (/^reserved: <([0-9a-f]*) ([0-9a-f]*) ([0-9a-f]*) ([0-9a-f]*)>;?$/) {
	    my ($addr_lo, $addr_hi, $len_lo, $len_hi) =
		(hex $1, hex $2, hex $3, hex $4);
	    my $addr = ($addr_hi << 32) + $addr_lo;
	    my $len = ($len_hi << 32) + $len_lo;
	    $mem_min = $addr + $len if $mem_min < $addr + $len;
	}
    }
    print "$mem_min\n";
} else {
    usage();
    exit(1);
}

# Swiss Army knife of Device Tree manipulation.
